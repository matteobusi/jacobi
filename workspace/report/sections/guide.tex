This section provides a short guide on how to use the program, how to conduct experiments and how to gather results.

\subsection{Workspace}
The workspace content is organized as follows:
\begin{itemize}
	\item The folder \verb|bin| contains the results of the compilation (including vectorization reports),
	\item the folder \verb|graphs| contains the graphs generated by \verb|reportgen.py|,
	\item the folder \verb|results| contains the collection of \verb|csv| files generated by \verb|jacobirun.sh|,
	\item the folder \verb|src| contains the source code of the program,
	\item the bash script \verb|jacobirun.sh| contains the code to run experiments,
	\item the Python program \verb|reportgen.py| that generates graphs starting from data in \verb|results| folder,
	\item the make file \verb|Makefile| compiles the project as explained in sub-section~\ref{subsec:compilation}.
\end{itemize}

In the following we assume that the current working directory is the root of the workspace.

\subsection{Compilation}\label{subsec:compilation}
To compile the project a \verb|Makefile| with four rules is provided:
\begin{enumerate}
	\item Executing \verb|make jacobix| the executable for the Xeon CPU is produced and placed in \verb|bin/jacobix|,
	\item executing \verb|make jacobim| the executable for the Xeon Phi is produced and placed in \verb|bin/jacobim|,
	\item executing \verb|make offload| the executable for the Xeon Phi is produced and placed in both \verb|bin/jacobim| and in the home directory on \verb|mic1|,
	\item executing \verb|make clean| the files produced by compilation, testing, and analysis are deleted.
\end{enumerate}

\subsection{Program usage}
To run a single resolution of a random system one of the compiled executables located in \verb|bin| must be run.
Executable \verb|jacobix| runs on the Xeon CPU, while executable \verb|jacobim| must be offloaded to the Xeon Phi.

Executing one of the executable without arguments produces as output a guide that should be self-explaining:
\begin{lstlisting}
Usage: ./jacobi N ITER ERR METHOD [NWORKERS] [GRAIN]
Where: 
	N : is the size of the matrix A
	ITER : is the maximum number of iterations
	ERR : is the maximum norm of an acceptable error
	METHOD: is either
		s : indicating that the sequential implementation must be used
		f : indicating that the FastFlow implementation must be used
		t : indicating that the Thread implementation must be used
	NWORKERS : the number of workers that should be used (ignored if METHOD is 's')
	GRAIN : the grain of the computation (only if METHOD is 'f')

Produces a CSV line, in the form:
N_WORKERS, N_ITERATIONS, COMP_TIME, UPD_TIME, CONV_TIME, LATENCY, ERROR
\end{lstlisting}

\subsection{Experiments and analysis}
After compilation, to execute the experiments and analyse the results one must:
\begin{enumerate}
	\item run \verb|./jacobirun.sh| or \verb|./jacobirun.sh MIC| (if Xeon Phi must be used), 
	\item run \verb|reportgen.py| to produce graphs.
\end{enumerate}









